1.最短路径问题

Dijkstra 算法

Dijkstra 算法是一种求解单源最短路径问题的算法，适用于带权有向图和无向图。它通过为每个顶点 v 保留一个距离值 dist[v]，从源顶点到顶点 v 的最短距离的上界。算法的关键思想是每次找到当前距离值最小的未访问顶点，然后根据它更新相邻顶点的距离值。

LeetCode 743. Network Delay Time

题目描述：有 N 个网络节点，从 1 到 N 标记。给定一个列表 times，表示信号从节点 u 传播到节点 v 所需的时间 w。现在，从某个节点 K 发出一个信号。需要找出多久后，所有节点都收到了信号。如果不是所有节点都能收到信号，则返回 -1。

解题思路：这是一个单源最短路径问题，可以使用 Dijkstra 算法求解。从节点 K 开始，遍历所有邻接节点，更新它们的距离值。然后，选择距离值最小的未访问节点，重复此过程。最后，返回最大的距离值

c++:
```c++
#include <vector>
#include <queue>
#include <limits>
#include <unordered_map>
using namespace std;

class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int N, int K) {
        unordered_map<int, vector<pair<int, int>>> graph;
        for (const auto& edge : times) {
            graph[edge[0]].emplace_back(edge[1], edge[2]);
        }

        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.emplace(0, K);

        unordered_map<int, int> dist;
        while (!pq.empty()) {
            int time = pq.top().first;
            int node = pq.top().second;
            pq.pop();

            if (dist.find(node) == dist.end()) {
                dist[node] = time;
                for (const auto& neighbor : graph[node]) {
                    int next_node = neighbor.first;
                    int edge_time = neighbor.second;
                    if (dist.find(next_node) == dist.end()) {
                        pq.emplace(time + edge_time, next_node);
                    }
                }
            }
        }

        if (dist.size() != N) return -1;
        int ans = 0;
        for (const auto& kv : dist) {
            ans = max(ans, kv.second);
        }
        return ans;
    }
};
```
python:
```python
import heapq
from collections import defaultdict

class Solution:
    def networkDelayTime(self, times: List[List[int]], N: int, K: int) -> int:
        graph = defaultdict(list)
        for u, v, w in times:
            graph[u].append((v, w))

        pq = [(0, K)]
        dist = {}

        while pq:
            time, node = heapq.heappop(pq)

            if node not in dist:
                dist[node] = time
                for next_node, edge_time in graph[node]:
                    if next_node not in dist:
                        heapq.heappush(pq, (time + edge_time, next_node))

        if len(dist) != N:
            return -1

        return max(dist.values())
```

