# 二分查找- Binary Search  
1. 有序数组的查找  
1. 时间复杂度为log(N)  
1. 数组分左右的问题  
1. 最大/最小的值，满足某些条件  

python代码模版
```python
#数组是有序的,下面的代码是对于一个递增的代码而言的，如果是递减的代码需要反过来
def binary_search(self,nums,target):
  if not nums:
    return -1
  
  n=len(nums)
  start=0
  end=n-1
  #while的判断使用了<=,为了防止无限循环的问题，left，right都是取值都不包括mid，如果left，right需要取mid，则判断语句需要取掉=
  while start<=end:
    mid=start+(end-start)//2
    if target>nums[mid]:
      left=mid+1
     elif target<nums[mid]:
      right=mid-1
     else:
      return mid
 
 return -1
```
# 双指针
1. 滑动窗口问题
2. 时间复杂度为O(N)的算法
3. 不使用额外空间的算法
4. 子字符，子串的算法
5. 回文


# 排序
## 快速排序
快速排序时间复杂度O(NlogN)
空间复杂度O(1)
是不稳定的，因为交换可能会影响先后顺序
```python 
def partition(nums,left,right):
    pivot=nums[right]
    k=left-1
    for i in range(left,right):
        if nums[i]<pivot:
            k+=1
            nums[k],nums[i]=nums[i],nums[k]
    nums[k+1],nums[right]=nums[right],nums[k+1]
    return k+1
def quick_sort(nums,left,right):
    if left>=right:
        return
    pivot_index=partition(nums,left,right)
    quick_sort(nums,left,pivot_index-1)
    quick_sort(nums,pivot_index+1,right)
```
## 归并排序 merge sort
快速排序时间复杂度O(NlogN)
空间复杂度O(N)
稳定的排序算法
```python
#merge_sort
def merge_sort(nums):
    if len(nums)<=1:
        return nums
    mid=len(nums)//2
    left=nums[0:mid]
    right=nums[mid:len(nums)]
    left=merge_sort(left)
    right=merge_sort(right)
    return merge(left,right)
def merge(left,right):
    left_index=right_index=0
    total=[]
    while left_index<len(left) and right_index<len(right):
        if left[left_index]<right[right_index]:
            total.append(left[left_index])
            left_index+=1
        else:
            total.append(right[right_index])
            right_index+=1
    while left_index<len(left):
        total.append(left[left_index])
        left_index+=1
    while right_index<len(right):
        total.append(right[right_index])
        right_index+=1
    return total
```
# 二叉树分治 binary tree divide conquer

    

    
